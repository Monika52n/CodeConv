# C++ to Java Converter Using Bloom Model

This project explores code conversion using the Bloom language model.

- **C++ → Java**: Fully functional, includes training data, scripts, and file conversion workflow.
- **Python → Java**: In an early experimental stage, scripts are in place, but there is no actual training data yet.


## Project Structure

### Training & Inference Scripts
- **`cpp-java-learn.py`**: Trains a model for C++ to Java code conversion using `cpp-java.jsonl` as training data.
- **`cpp-java-test.py`**: Uses the trained model to convert C++ code (from `cpp_test_files.json`) to Java.

- **`py-java-learn.py`**: Trains a model for Python to Java code conversion using `py-java.jsonl`.
- **`py-java-test.py`**: Converts Python code to Java using the trained model.

### Data Files
- **`cpp-java.jsonl`**: Training data for C++ to Java conversion.
- **`py-java.jsonl`**: Training data for Python to Java conversion.
- **`cpp_test_files.json`**: Contains C++ test code snippets to be converted to Java.

### Utilities
- **`cpp-reader.py`**: Reads C++ files from the `cpp-test-files/` folder and saves their contents to `cpp_test_files.json`.

### Folders
- **`cpp-test-files/`**: Contains sample C++ files for testing the conversion.
- **`java-files/`**: Holds the Java files generated by the converter.
- **`java-files-corrected/`**: Manually reviewed Java files copied from `java-files/`. If a file is correct, its filename includes `_ok`.

## Usage
1. Prepare or update training data in `.jsonl` format.
2. Train the model using `cpp-java-learn.py`.
3. Run `cpp-reader.py` to generate the test file list from `cpp-test-files/`.
4. Use `cpp-java-test.py` to convert C++ test files to Java.
5. Review and move correct Java files to `java-files-corrected/`.

## Training Data

The dataset created for our experiments includes code segments from the following categories:

- **Basic Functions**: Simple functions such as factorial or Fibonacci.
- **Control Structures**: Examples using `for`, `while`, `foreach`, `switch`, and `if` statements.
- **Class Definitions and Inheritance**: Object-oriented constructs including base and derived classes.
- **Fundamental Data Structures**: Arrays, lists, and maps.
- **Simple Algorithms**: Basic logic like minimum/maximum selection.
- **String Operations**: Manipulating and processing string data.
- **File I/O**: Reading from and writing to files.
- **Structs and Enums**: Examples involving custom data types and enumerations.

## Results

### Examples of Generated Code

The model was able to successfully translate several basic programming constructs. For instance:

Python input
```python
def factorial(n):
    return 1 if n == 0 else n * factorial(n - 1)
```

Java output
```java
public static int factorial(int n) {
    return n == 0 ? 1 : n * factorial(n - 1);
}
```

### Types of Errors
The most common types of errors observed during the experiments were:

1. **Syntactic errors**:
Missing semicolons, braces, or parentheses in the generated Java code.

2. **Incorrect mapping of language-specific constructs**:
For example, Python- or C++-specific features were sometimes improperly translated into Java.

3. **Memory handling differences**:
Code using C++-style pointers or manual memory management caused issues in Java, which uses a different memory model.

4. **Incomplete translations**:
In some cases, the output Java code lacked essential parts of the original logic or structure.

5. **Stylistic or non-idiomatic Java**:
While the generated Java code may compile and run correctly, it does not always follow typical Java conventions or best practices.